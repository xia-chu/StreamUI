<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <style>
    .player-container {
      max-width: 1000px;
      margin: auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    video {
      width: 1024px;
      height: 576px;
      background: #23292e;
      margin: 20px 0 40px 0;
    }

    .timeline-container {
      position: relative;
      height: 80px;
      margin: 30px 0;
      user-select: none;
    }

    .timeline-track {
      position: absolute;
      left: 0;
      right: 0;
      top: 30px;
      height: 6px;
      background: #e0e0e0;
      border-radius: 3px;
      overflow: hidden;
    }

    .timeline-segments {
      position: absolute;
      left: 0;
      right: 0;
      top: 30px;
      height: 6px;
    }

    .segment {
      position: absolute;
      height: 100%;
      background: #4caf50;
      border-right: 1px solid rgba(255, 255, 255, 0.5);
    }

    .segment:hover {
      background: #45a049;
    }

    .timeline-labels {
      position: absolute;
      top: 50px;
      left: 0;
      right: 0;
      font-size: 12px;
      color: #555;
      white-space: nowrap;
      overflow: visible;
    }

    .label {
      position: absolute;
      transform: translateX(-50%);
    }

    .playhead {
      position: absolute;
      top: 20px;
      width: 2px;
      height: 40px;
      background: red;
      z-index: 10;
      transform: translateX(-50%);
      cursor: grab;
    }

    .playhead::after {
      content: "▶";
      position: absolute;
      top: -10px;
      left: -6px;
      font-size: 16px;
      color: red;
    }

    .playhead.dragging {
      cursor: grabbing;
    }

    .current-time {
      position: absolute;
      top: 0px;
      left: 0;
      font-size: 12px;
      color: #333;
      padding: 2px 5px;
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid #ddd;
      border-radius: 3px;
    }
  </style>
</head>

<body>
  <div style="padding: 16px">
    <div class="layui-card">
      <div class="layui-card-header">本地录像管理</div>
      <div class="layui-card-body">
        <table class="layui-hide" id="ID_recorded_video_table"></table>
      </div>
    </div>
  </div>

  <!-- toolbar 模板 -->
  <script id="ID_tpl_toolbar" type="text/html">
      <a
        class="layui-btn layui-btn-xs"
        lay-event="play"
        style="background-color: #16baaa"
        >查看录像</a
      >
      <a
        class="layui-btn layui-btn-xs"
        lay-event="del"
        style="background-color: #ff5722"
        >删除</a
      >
    </script>

  <!-- 录像播放界面模板 -->
  <script id="ID_tpl_recorded_video_player" type="text/html">
      <div class="layui-form" style="margin-top: 16px">
        <div class="layui-form-item">
          <div class="layui-inline">
            <label class="layui-form-label">录像日期</label>
            <div class="layui-input-inline">
              <select id="ID_video_date" lay-filter="video_date">
                <!-- 日期选择器 -->
                <!-- 选项由 JS 动态生成 -->
              </select>
            </div>
          </div>
        </div>
      </div>

      <!-- 视频播放器 -->
      <div
        style="margin: 0 30px 0 30px; display: flex;justify-content: center;"
      >
        <video id="ID_player" controls autoplay></video>
      </div>

      <!-- 时间轴容器 -->
      <div
        class="timeline-container"
        id="timeline"
        style="margin: 0 80px 0 80px"
      >
        <div class="timeline-track"></div>
        <div class="timeline-segments" id="segments"></div>
        <div class="timeline-labels" id="labels"></div>
        <div class="playhead" id="playhead"></div>
        <div class="current-time" id="currentTime">--:--:--</div>
      </div>
    </script>

  <script>
    layui.use(function () {
      let layer = layui.layer;
      let table = layui.table;
      let $ = layui.jquery;
      let form = layui.form;

      function toNginxPath(path) {
        return "/record/" + path;
      }

      // 解析时间字符串为时间戳(ms)
      function parseTime(timeStr) {
        return new Date(timeStr).getTime();
      }

      // 格式化时间戳为 HH:mm:ss
      function formatTime(ts) {
        let d = new Date(ts);
        return d.toTimeString().substr(0, 8);
      }

      let playbackSessionId = 0;
      let currentPlayback = null;
      let playbackController = null;
      let recordingsCache = new Map();

      function createPlaybackController() {
        const videoPlayer = document.getElementById("ID_player");
        const timeline = document.getElementById("timeline");
        const segmentsContainer = document.getElementById("segments");
        const labelsContainer = document.getElementById("labels");
        const playhead = document.getElementById("playhead");
        const currentTimeEl = document.getElementById("currentTime");

        let recordings = [];
        let startTime = 0;
        let endTime = 0;
        let durationMs = 1;
        let isDragging = false;
        let isDestroyed = false;
        let rafSeekId = 0;
        let pendingSeekTs = null;

        const onMouseMove = (e) => {
          if (!isDragging || !timeline) return;
          const rect = timeline.getBoundingClientRect();
          let x = e.clientX - rect.left;
          if (x < 0) x = 0;
          if (x > rect.width) x = rect.width;
          const timeTs = startTime + (x / rect.width) * durationMs;
          seekTo(timeTs);
        };

        const onMouseUp = () => {
          if (!isDragging) return;
          isDragging = false;
          playhead?.classList.remove("dragging");
        };

        const onPlayheadDown = (e) => {
          isDragging = true;
          playhead?.classList.add("dragging");
          e.preventDefault();
        };

        const onTimelineClick = (e) => {
          if (!timeline) return;
          const rect = timeline.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const timeTs = startTime + (x / rect.width) * durationMs;
          seekTo(timeTs);
        };

        const onEnded = () => {
          if (!videoPlayer || recordings.length === 0) return;
          const src = videoPlayer.src || "";
          const currentIndex = recordings.findIndex((rec) =>
            src.endsWith(rec.filename)
          );
          if (currentIndex !== -1 && currentIndex + 1 < recordings.length) {
            const nextRecording = recordings[currentIndex + 1];
            const nextStart = parseTime(nextRecording.start);
            seekTo(nextStart + 1000);
          }
        };

        const onTimeUpdate = () => {
          if (isDragging) return;
          if (!videoPlayer || recordings.length === 0) return;
          if (!videoPlayer.src) return;

          let filename = null;
          try {
            const url = new URL(videoPlayer.src);
            filename = url.pathname;
          } catch (e) {
            return;
          }

          const rec = recordings.find((r) => r.filename === filename);
          if (!rec) return;

          const videoLocalTime = videoPlayer.currentTime * 1000;
          const videoStartTime = parseTime(rec.start);
          const absoluteTime = videoStartTime + videoLocalTime;

          updatePlayhead(absoluteTime);
        };

        function clearTimeline() {
          if (segmentsContainer) segmentsContainer.innerHTML = "";
          if (labelsContainer) labelsContainer.innerHTML = "";
          if (playhead) playhead.style.left = "0px";
          if (currentTimeEl) {
            currentTimeEl.style.left = "0px";
            currentTimeEl.textContent = "--:--:--";
          }
        }

        function renderTimeline() {
          if (!timeline || !segmentsContainer || !labelsContainer) return;
          segmentsContainer.innerHTML = "";
          labelsContainer.innerHTML = "";

          const pxPerMs = timeline.offsetWidth / durationMs;
          const frag = document.createDocumentFragment();

          recordings.forEach((rec) => {
            const s = parseTime(rec.start);
            const e = parseTime(rec.end);
            const width = (e - s) * pxPerMs;
            const left = (s - startTime) * pxPerMs;
            const seg = document.createElement("div");
            seg.className = "segment";
            seg.style.left = `${left}px`;
            seg.style.width = `${width}px`;
            frag.appendChild(seg);
          });
          segmentsContainer.appendChild(frag);

          const current = new Date(startTime);
          current.setMinutes(0, 0, 0);
          let t = current.getTime();
          const labelsFrag = document.createDocumentFragment();
          while (t <= endTime) {
            const left = (t - startTime) * pxPerMs;
            if (left >= 0 && left <= timeline.offsetWidth) {
              const label = document.createElement("div");
              label.className = "label";
              label.style.left = `${left}px`;
              const d = new Date(t);
              const h = String(d.getHours()).padStart(2, "0");
              const m = String(d.getMinutes()).padStart(2, "0");
              label.textContent = `${h}:${m}:00`;
              labelsFrag.appendChild(label);
            }
            t += 60 * 60 * 1000;
          }
          labelsContainer.appendChild(labelsFrag);
        }

        function updatePlayhead(timeTs) {
          if (!timeline || !playhead || !currentTimeEl) return;
          const pxPerMs = timeline.offsetWidth / durationMs;
          const left = (timeTs - startTime) * pxPerMs;
          playhead.style.left = `${left}px`;
          currentTimeEl.style.left = `${left + 10}px`;
          currentTimeEl.textContent = formatTime(timeTs);
        }

        function seekTo(timeTs) {
          if (!timeline || !videoPlayer || recordings.length === 0) return;
          if (pendingSeekTs === null) pendingSeekTs = timeTs;
          else pendingSeekTs = timeTs;

          if (rafSeekId) return;
          rafSeekId = requestAnimationFrame(() => {
            rafSeekId = 0;
            if (pendingSeekTs === null || isDestroyed) return;
            const ts = pendingSeekTs;
            pendingSeekTs = null;

            updatePlayhead(ts);

            const rec = recordings.find(
              (r) => ts >= parseTime(r.start) && ts <= parseTime(r.end)
            );
            if (!rec) return;

            const videoStart = parseTime(rec.start);
            const seekTimeInVideo = Math.max(0, (ts - videoStart) / 1000);

            const currentSrc = videoPlayer.src || "";
            const isSameFile = currentSrc.endsWith(rec.filename);

            if (isSameFile) {
              videoPlayer.currentTime = seekTimeInVideo;
              return;
            }

            videoPlayer.onloadedmetadata = function () {
              videoPlayer.currentTime = seekTimeInVideo;
              const p = videoPlayer.play();
              if (p && typeof p.catch === "function") p.catch(() => { });
              videoPlayer.onloadedmetadata = null;
            };
            videoPlayer.src = rec.filename;
            videoPlayer.load();
          });
        }

        function cleanup() {
          isDestroyed = true;
          if (rafSeekId) cancelAnimationFrame(rafSeekId);
          rafSeekId = 0;
          pendingSeekTs = null;

          playhead?.removeEventListener("mousedown", onPlayheadDown);
          timeline?.removeEventListener("click", onTimelineClick);
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);

          videoPlayer?.removeEventListener("ended", onEnded);
          videoPlayer?.removeEventListener("timeupdate", onTimeUpdate);

          if (videoPlayer) {
            videoPlayer.pause();
            videoPlayer.removeAttribute("src");
            videoPlayer.load();
          }
          clearTimeline();
        }

        playhead?.addEventListener("mousedown", onPlayheadDown);
        timeline?.addEventListener("click", onTimelineClick);
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);

        videoPlayer?.addEventListener("ended", onEnded);
        videoPlayer?.addEventListener("timeupdate", onTimeUpdate);

        clearTimeline();

        return {
          setRecordings: function (list) {
            recordings = Array.isArray(list) ? list : [];
            recordings = recordings
              .slice()
              .sort((a, b) => parseTime(a.start) - parseTime(b.start));

            if (recordings.length === 0) {
              clearTimeline();
              if (currentTimeEl) currentTimeEl.textContent = "无录像";
              return;
            }

            startTime = parseTime(recordings[0].start);
            endTime = parseTime(recordings[recordings.length - 1].end);
            durationMs = Math.max(1, endTime - startTime);

            renderTimeline();
            updatePlayhead(startTime);
            seekTo(startTime);
          },
          cleanup,
        };
      }

      function loadRecordings(app, stream, date) {
        if (!currentPlayback || currentPlayback.app !== app || currentPlayback.stream !== stream) {
          return;
        }
        const key = `${app}||${stream}||${date}`;

        const useData = (list) => {
          const recordings = (Array.isArray(list) ? list : []).map((rec) => ({
            ...rec,
            filename: toNginxPath(rec.filename),
          }));
          playbackController?.setRecordings(recordings);
        };

        if (recordingsCache.has(key)) {
          useData(recordingsCache.get(key));
          return;
        }

        let loading = layer.load(2, { shade: [0.1, "#fff"] });
        $.ajax({
          url: `/api/playback/streamid-record?app=${encodeURIComponent(
            app
          )}&stream=${encodeURIComponent(stream)}&date=${encodeURIComponent(date)}`,
          type: "GET",
          dataType: "json",
          timeout: 10000,
          success: function (res) {
            if (!res || res.code !== 0) {
              layer.msg("⚠️ 获取录像失败", {
                time: 1500,
                offset: "t",
                shift: 1,
              });
              useData([]);
              return;
            }
            const list = Array.isArray(res.data) ? res.data : [];
            recordingsCache.set(key, list);
            useData(list);
          },
          error: function () {
            layer.msg("⚠️ 获取录像失败", {
              time: 1500,
              offset: "t",
              shift: 1,
            });
            useData([]);
          },
          complete: function () {
            layer.close(loading);
          },
        });
      }

      // 表格渲染
      function renderTable() {
        let loading = layer.load(2, { shade: [0.1, "#fff"] });
        $.ajax({
          url: `/api/playback/streamid-record-list`,
          type: "GET",
          dataType: "json",
          timeout: 10000,
          success: function (res) {
            if (res.code === 0) {
              let data = res.data || [];
              table.render({
                elem: "#ID_recorded_video_table",
                data: data,
                cols: [
                  [
                    {
                      field: "id",
                      title: "序号",
                      align: "center",
                      width: 80,
                      templet: function (d) {
                        return d.LAY_NUM;
                      },
                    },
                    {
                      field: "app",
                      title: "应用名",
                      align: "center",
                      width: 150,
                    },
                    {
                      field: "stream",
                      title: "流ID",
                      align: "center",
                      width: 200,
                    },
                    {
                      field: "slice_num",
                      title: "切片数",
                      align: "center",
                      width: 150,
                    },
                    {
                      field: "total_storage_gb",
                      title: "总存储容量",
                      align: "center",
                      width: 150,
                      templet: function (d) {
                        return `<div>${d.total_storage_gb} GB</div>`;
                      },
                    },
                    // {
                    //   field: "record_days",
                    //   title: "录像保留(天)",
                    //   align: "center",
                    //   width: 150,
                    //   templet: function (d) {
                    //     return `<div>${d.record_days}</div>`;
                    //   },
                    // },
                    {
                      field: "operate",
                      title: "操作",
                      width: 200, // 调整宽度以容纳两个按钮
                      align: "center",
                      toolbar: "#ID_tpl_toolbar", // 推荐使用模板（更清晰）
                    },
                  ],
                ],
                page: true,
                limits: [8, 16, 32],
                limit: 8,
              });
            }
          },
          error: function () {
            layer.msg("❌ 录像列表请求失败", {
              time: 1500,
              offset: "t",
              shift: 1,
            });
          },
          complete: function () {
            layer.close(loading);
          },
        });
      }

      // 监听表格按钮
      table.on("tool(ID_recorded_video_table)", function (obj) {
        let objData = obj.data; // 当前行数据
        let layEvent = obj.event; // 获取 lay-event 的值 del, play

        //   // 在页面加载时绑定一次即可
        if (layEvent === "play") {
          playbackSessionId += 1;
          const sessionId = playbackSessionId;
          layer.open({
            type: 1,
            title: "回看",
            area: ["100%", "100%"],
            content: $("#ID_tpl_recorded_video_player").html(),
            btn: [],
            success: function (layero, index) {
              let availableDates = objData.dates || [];
              if (availableDates.length === 0) {
                layer.msg("⚠️ 暂无录像", {
                  time: 1500,
                  offset: "t",
                  shift: 1,
                });
                layer.close(index);
                return;
              }

              availableDates.sort();

              let $select = $("#ID_video_date");
              $select.empty();

              availableDates.forEach((date) => {
                $select.append(`<option value="${date}">${date}</option>`);
              });

              currentPlayback = {
                app: objData.app,
                stream: objData.stream,
                sessionId: sessionId,
              };

              form.render("select");

              if (playbackController) playbackController.cleanup();
              playbackController = createPlaybackController();

              $select.val(availableDates[0]);
              form.render("select");
              loadRecordings(objData.app, objData.stream, availableDates[0]);
            },
            end: function () {
              if (currentPlayback && currentPlayback.sessionId === sessionId) {
                currentPlayback = null;
              }
              if (playbackController) {
                playbackController.cleanup();
                playbackController = null;
              }
            },
          });
        } else if (layEvent === "del") {
          // 删除确认
          layer.confirm(
            `确定要删除录像<span style = "margin-bottom: 6px; padding: 4px; background: #f7f7f7; border-radius: 4px;">${objData.app}/${objData.stream}</span>吗？`,
            { title: "提示" },
            function (index) {
              $.ajax({
                url: `/api/playback/streamid-record?app=${objData.app}&stream=${objData.stream}`,
                type: "DELETE",
                dataType: "json",
                timeout: 10000,
                success: function (res) {
                  if (res.code === 0) {
                    layer.msg("✅ 删除成功", {
                      time: 1500,
                      offset: "t",
                      shift: 1,
                    });
                    renderTable();
                  } else {
                    layer.msg("⚠️ 删除失败", {
                      time: 1500,
                      offset: "t",
                      shift: 1,
                    });
                  }
                },
                error: function () {
                  layer.msg("⚠️ 删除失败", {
                    time: 1500,
                    offset: "t",
                    shift: 1,
                  });
                },
              });
              layer.close(index);
            }
          );
        }
      });

      form.on("select(video_date)", function (rec) {
        if (!currentPlayback) return;
        loadRecordings(currentPlayback.app, currentPlayback.stream, rec.value);
      });

      renderTable();
    });
  </script>
</body>

</html>